enum Option {
    Some(value),
    None,
}

// reverse(a[]) -> a[]
fn reverse(list) { reverse(list, []) }
// reverse(a[], a[]) -> a[]
fn reverse([], acc) { acc }
fn reverse([x, ...xs], acc) { rec reverse(xs, [x, ...acc]) }

// reduce(a[], fn(b, a) -> b, b) -> b
fn reduce([], _, acc) { acc }
fn reduce([x, ...xs], f, acc) { rec reduce(xs, f, f(acc, x)) }

// find(a[], fn(a) -> bool) -> Option(a)
fn find(list, predicate) { find(list, predicate, Option::None) }
// find(a[], fn(a) -> bool, Option(a)) -> Option(a)
fn find([], _, acc) { acc }
fn find([x], predicate, _) if predicate(x) { Option::Some(x) }
fn find([_, ...xs], predicate, acc) { rec find(xs, predicate, acc) }

// all(a[], fn(a) -> bool) -> bool
fn all(list, predicate) { all(list, predicate, true) }
// all(a[], fn(a) -> bool, bool) -> bool
fn all([], _, acc) { acc }
fn all([x], predicate, _) if not predicate(x) { false }
fn all([_, ...xs], predicate, acc) { rec all(xs, predicate, acc) }

// any(a[], fn(a) -> bool) -> bool
fn any(list, predicate) { any(list, predicate, false) }
// any(a[], fn(a) -> bool, bool) -> bool
fn any([], _, acc) { acc }
fn any([x], predicate, _) if predicate(x) { true }
fn any([_, ...xs], predicate, acc) { rec any(xs, predicate, acc) }

// flatten(a[][]) -> a[]
fn flatten(list) { flatten(list, []) }
// flatten(a[][], a[]) -> a[]
fn flatten([], acc) { acc }
fn flatten([x, ...xs], acc) { rec flatten(xs, [...acc, ...x]) }

// take(a[], int) -> a[]
fn take(list, n) { take(list, n, []) }
// take(a[], int, a[]) -> a[]
fn take([], _, acc) { acc }
fn take([x, ...xs], n, acc) if n > 0 { rec take(xs, n - 1, [...acc, x]) }
fn take(_, _, acc) { acc }

// drop(a[], int) -> a[]
fn drop(list, n) { drop(list, n, []) }
// drop(a[], int, a[]) -> a[]
fn drop([], _, acc) { acc }
fn drop([_, ...xs], n, acc) if n > 0 { rec drop(xs, n - 1, acc) }
fn drop([x, ...xs], _, acc) { rec drop(xs, 0, [...acc, x]) }

// Reverse the list
[1, 2, 3, 4, 5]
|> reverse()
|> log();

// Calculate the sum of the list elements
[1, 2, 3, 4, 5]
|> reduce(fn (acc, x) { acc + x }, 0)
|> log();

// Find the first element greater than 3
[1, 2, 3, 4, 5]
|> find(fn (x) { x > 3 })
|> log();

// Check if all elements are less than 6
[1, 2, 3, 4, 5]
|> all(fn (x) { x < 6 })
|> log();

// Check if any element is greater than 4
[1, 2, 3, 4, 5]
|> any(fn (x) { x > 4 })
|> log();

// Flatten the list of lists
[[1, 2], [3, 4], [5]]
|> flatten()
|> log();

// Take the first three elements
[1, 2, 3, 4, 5]
|> take(3)
|> log();

// Drop the first two elements
[1, 2, 3, 4, 5]
|> drop(2)
|> log();

// len(a[]) -> int
fn len(list) { list.length }

// random_int(int) -> int
fn random_int(max) { random() * max |> floor() }

// partition(a[], fn(a) -> bool) -> (a[], a[])
fn partition([], _) { [[], []] }
fn partition(list, predicate) { partition(list, predicate, [], []) }
// partition(a[], fn(a) -> bool, a[], a[]) -> (a[], a[])
fn partition([], _, satisfies, does_not_satisfy) { [satisfies, does_not_satisfy] }
fn partition([x, ...xs], predicate, satisfies, does_not_satisfy) if predicate(x) {
  rec partition(xs, predicate, [...satisfies, x], does_not_satisfy)
}
fn partition([x, ...xs], predicate, satisfies, does_not_satisfy) {
  rec partition(xs, predicate, satisfies, [...does_not_satisfy, x])
}

// quicksort(a[], fn(a, a) -> int) -> a[]
fn quicksort([], _) { [] }
fn quicksort(list, predicate) {
  let pivotIndex = random_int(len(list));
  let pivot = list[pivotIndex];
  let list = [...list.slice(0, pivotIndex), ...list.slice(pivotIndex+1)];

  let [smaller, greater] = list |> partition(fn(x) { predicate(x, pivot) < 0 });

  let smaller = smaller |> quicksort(predicate);
  let greater = greater |> quicksort(predicate);

  [...smaller, pivot, ...greater]
}

[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
|> quicksort(fn(a, b) { b - a })
|> log();

// apply_map(fn(a) -> b, b[], a) -> b[]
fn apply_map(f, acc, x) { [ ...acc, f(x) ] }

// apply_filter(fn(a) -> bool, a[], a) -> a[]
fn apply_filter(f, acc, x) if f(x) { [ ...acc, x ] }
fn apply_filter(_, acc, _) { acc }

// map(a[], fn(a) -> b) -> b[]
fn map(xs, f) { foldl(xs, [], apply_map(f, _, _)) }

// filter(a[], fn(a) -> bool) -> a[]
fn filter(xs, f) { foldl(xs, [], apply_filter(f, _, _)) }

// foldl(a[], b, fn(b, a) -> b) -> b
fn foldl([], acc, _) { acc }
fn foldl([x, ...xs], acc, f) { rec foldl(xs, f(acc, x), f) }

[1,2,3,4,5]
|> map(fn (x) { x ** 2 })
|> filter(fn (x) { x % 2 == 0 })
|> foldl(0, fn (acc, x) { acc + x })
|> log();

// binary_search(a[], a) -> int
fn binary_search(list, target) { binary_search(list, target, 0, len(list) - 1) }
// binary_search(a[], a, int, int) -> int
fn binary_search(_, _, low, high) if low > high; { -1 }
// binary_search(a[], a, int, int) -> int
fn binary_search(list, target, low, high) {
    let mid = floor((low + high) / 2);
    let midValue = list[mid];

    if midValue == target; {
        mid
    } else if midValue < target; {
        binary_search(list, target, mid + 1, high)
    } else {
        binary_search(list, target, low, mid - 1)
    }
}

[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
|> binary_search(7)
|> log();

enum Expr {
    Value(int),
    Add(LExpr, RExpr),
    Subtract(LExpr, RExpr),
    Multiply(LExpr, RExpr),
    Divide(LExpr, RExpr),
}

// evaluate(Expr) -> int
fn evaluate(Expr::Value(val)) { val }
fn evaluate(Expr::Add(left, right)) { evaluate(left) + evaluate(right) }
fn evaluate(Expr::Subtract(left, right)) { evaluate(left) - evaluate(right) }
fn evaluate(Expr::Multiply(left, right)) { evaluate(left) * evaluate(right) }
fn evaluate(Expr::Divide(left, right)) { evaluate(left) / evaluate(right) }

// Example Usage
let expr = Expr::Add(
    Expr::Multiply(
        Expr::Value(2),
        Expr::Value(3)
    ),
    Expr::Subtract(
        Expr::Value(10),
        Expr::Value(4)
    )
);

expr
|> evaluate()
|> log();

enum Expr {
    Value(int),
    Add(LExpr, RExpr),
    Subtract(LExpr, RExpr),
    Multiply(LExpr, RExpr),
    Divide(LExpr, RExpr),
}

// evaluate(Expr) -> int
fn evaluate(Expr::Value(val)) { val }
fn evaluate(Expr::Add(left, right)) { evaluate(left) + evaluate(right) }
fn evaluate(Expr::Subtract(left, right)) { evaluate(left) - evaluate(right) }
fn evaluate(Expr::Multiply(left, right)) { evaluate(left) * evaluate(right) }
fn evaluate(Expr::Divide(left, right)) { evaluate(left) / evaluate(right) }

// Example Usage
let expr = Expr::Add(
    Expr::Multiply(
        Expr::Value(2),
        Expr::Value(3)
    ),
    Expr::Subtract(
        Expr::Value(10),
        Expr::Value(4)
    )
);

expr
|> evaluate()
|> log();

// filter_map(a[], fn(a) -> Option(b)) -> b[]
fn filter_map([], _) { [] }
fn filter_map([x, ...xs], f) if let Option::Some(y) = f(x) { [y, ...filter_map(xs, f)] }
fn filter_map([_, ...xs], f) { rec filter_map(xs, f) }

[1,2,3,4,5]
|> filter_map(fn(x) { if x % 2 == 0 { Option::Some(x ** 2) } else { Option::None } })
|> log();

// reverse_string(string) -> string
fn reverse_string(str) { reverse_string(str, "") }
// reverse_string(string, string) -> string
fn reverse_string("", acc) { acc }
fn reverse_string([x, ...xs], acc) { rec reverse_string(xs, x + acc) }

// is_palindrome(string) -> bool
fn is_palindrome(str) { str == reverse_string(str) }

"racecar"
|> is_palindrome()
|> log();

"hello"
|> is_palindrome()
|> log();


enum Tree {
    Leaf(x),
    Node { left, right },
}

// maximum_depth(Tree) -> Int
fn maximum_depth(Tree::Leaf(_)) { 1 }
fn maximum_depth(Tree::Node { left, right }) {
    1 + max(maximum_depth(left), maximum_depth(right))
}

let x = Tree::Node {
    left: Tree::Leaf(1),
    right: Tree::Node {
        left: Tree::Leaf(2),
        right: Tree::Node {
            left: Tree::Node {
                left: Tree::Leaf(4),
                right: Tree::Leaf(5),
            },
            right: Tree::Leaf(6),
        },
    },
};

x
|> maximum_depth()
|> log();

// zip(a[], b[]) -> [a, b][]
fn zip([], []) { [] }
fn zip([x, ...xs], [y, ...ys]) { [[x, y], ...zip(xs, ys)] }

let list1 = [1, 2, 3];
let list2 = ["a", "b", "c"];

list1
|> zip(list2)
|> log();
