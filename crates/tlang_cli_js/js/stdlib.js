// This file was auto-generated by the tlang compiler.
const Option = {
    Some(value) {
        return {
            tag: "Some",
            [0]: value,
        };
    },
    None: { tag: "None" },
};
const Result = {
    Ok(value) {
        return {
            tag: "Ok",
            [0]: value,
        };
    },
    Err(error) {
        return {
            tag: "Err",
            [0]: error,
        };
    },
};
// len(a[]) -> int
function len(list) {
    return list.length;
}
// random_int(int) -> int
function random_int(max) {
    return Math.floor(Math.random() * max);
}
// compose(fn(a) -> b, fn(b) -> c) -> fn(a) -> c
function compose(f, g) {
    return function(x) {
        return f(g(x));
    };
}
// map(a[], fn(a) -> b) -> b[]
function map(arg0, f) {
    if (arg0.length === 0) {
        // map(a[], fn(a) -> b) -> b[]
        return [];
    } else if (arg0.length >= 1) {
        let x = arg0[0];
        let xs = arg0.slice(1);
        return [f(x), ...map(xs, f)];
    }
}
// filter(a[], fn(a) -> bool) -> a[]
function filter(arg0, f) {
    while (true) {
        if (arg0.length === 0) {
            // filter(a[], fn(a) -> bool) -> a[]
            return [];
        } else if (arg0.length >= 1 && f(arg0[0])) {
            let x = arg0[0];
            let xs = arg0.slice(1);
            return [x, ...filter(xs, f)];
        } else if (arg0.length >= 1) {
            let xs = arg0.slice(1);
            let $tmp$1 = xs;
            let $tmp$2 = f;
            arg0 = $tmp$1;
            f = $tmp$2;
        }
    }
}
// partition(a[], fn(a) -> bool) -> (a[], a[])
// partition(a[], fn(a) -> bool, a[], a[]) -> (a[], a[])
function partition(...args) {
    while (true) {
        if (args.length === 2 && args[0].length === 0) {
            // partition(a[], fn(a) -> bool) -> (a[], a[])
            return [[], []];
        } else if (args.length === 2) {
            let list = args[0];
            let predicate = args[1];
            return partition(list, predicate, [], []);
        } else if (args.length === 4 && args[0].length === 0) {
            // partition(a[], fn(a) -> bool, a[], a[]) -> (a[], a[])
            let satisfies = args[2];
            let does_not_satisfy = args[3];
            return [satisfies, does_not_satisfy];
        } else if (args.length === 4 && args[0].length >= 1 && args[1](args[0][0])) {
            let predicate = args[1];
            let satisfies = args[2];
            let does_not_satisfy = args[3];
            let x = args[0][0];
            let xs = args[0].slice(1);
            let $tmp$1 = xs;
            let $tmp$2 = predicate;
            let $tmp$3 = [...satisfies, x];
            let $tmp$4 = does_not_satisfy;
            args[0] = $tmp$1;
            args[1] = $tmp$2;
            args[2] = $tmp$3;
            args[3] = $tmp$4;
        } else if (args.length === 4 && args[0].length >= 1) {
            let predicate = args[1];
            let satisfies = args[2];
            let does_not_satisfy = args[3];
            let x = args[0][0];
            let xs = args[0].slice(1);
            let $tmp$1 = xs;
            let $tmp$2 = predicate;
            let $tmp$3 = satisfies;
            let $tmp$4 = [...does_not_satisfy, x];
            args[0] = $tmp$1;
            args[1] = $tmp$2;
            args[2] = $tmp$3;
            args[3] = $tmp$4;
        }
    }
}
// filter_map(a[], fn(a) -> Option(b)) -> b[]
function filter_map(arg0, f) {
    let $tmp$0;
    let y;
    while (true) {
        if (arg0.length === 0) {
            // filter_map(a[], fn(a) -> Option(b)) -> b[]
            return [];
        } else if (arg0.length >= 1 && ($tmp$0 = f(arg0[0])) && $tmp$0.tag === "Some" && ((y = $tmp$0[0]), true)) {
            let x = arg0[0];
            let xs = arg0.slice(1);
            return [y, ...filter_map(xs, f)];
        } else if (arg0.length >= 1) {
            let xs = arg0.slice(1);
            let $tmp$2 = xs;
            let $tmp$3 = f;
            arg0 = $tmp$2;
            f = $tmp$3;
        }
    }
}
// foldl(a[], b, fn(b, a) -> b) -> b
function foldl(arg0, acc, f) {
    while (true) {
        if (arg0.length === 0) {
            // foldl(a[], b, fn(b, a) -> b) -> b
            return acc;
        } else if (arg0.length >= 1) {
            let x = arg0[0];
            let xs = arg0.slice(1);
            let $tmp$1 = xs;
            let $tmp$2 = f(acc, x);
            let $tmp$3 = f;
            arg0 = $tmp$1;
            acc = $tmp$2;
            f = $tmp$3;
        }
    }
}
// foldr(a[], b, fn(a, b) -> b) -> b
function foldr(arg0, acc, f) {
    if (arg0.length === 0) {
        // foldr(a[], b, fn(a, b) -> b) -> b
        return acc;
    } else if (arg0.length >= 1) {
        let x = arg0[0];
        let xs = arg0.slice(1);
        return f(x, foldr(xs, acc, f));
    }
}
// sum(int[] xs) -> int
function sum(arg0) {
    if (arg0.length === 0) {
        // sum(int[] xs) -> int
        return 0;
    } else if (arg0.length >= 1) {
        let x = arg0[0];
        let xs = arg0.slice(1);
        return x + sum(xs);
    }
}
// zip(a[], b[]) -> [a, b][]
function zip(arg0, arg1) {
    if (arg0.length === 0 && arg1.length === 0) {
        // zip(a[], b[]) -> [a, b][]
        return [];
    } else if (arg0.length >= 1 && arg1.length >= 1) {
        let x = arg0[0];
        let xs = arg0.slice(1);
        let y = arg1[0];
        let ys = arg1.slice(1);
        return [[x, y], ...zip(xs, ys)];
    }
}
