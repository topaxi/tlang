// Simple sorting and list algorithms
// Demonstrates: basic algorithms, recursion, list processing

// Helper functions
fn filter([], _) { [] }
fn filter([x, ...xs], f) if f(x) { [x, ...filter(xs, f)] }
fn filter([_, ...xs], f) { rec filter(xs, f) }

fn append([], ys) { ys }
fn append([x, ...xs], ys) { [x, ...append(xs, ys)] }

// Simple insertion sort
fn insert_sort([]) { [] }
fn insert_sort([x, ...xs]) {
    insert(x, insert_sort(xs))
}

fn insert(x, []) { [x] }
fn insert(x, [y, ...ys]) if x <= y {
    [x, y, ...ys]
}
fn insert(x, [y, ...ys]) {
    [y, ...insert(x, ys)]
}

// Simple quicksort using first element as pivot
fn simple_quicksort([]) { [] }
fn simple_quicksort([pivot, ...rest]) {
    let smaller = filter(rest, fn(x) { x <= pivot });
    let larger = filter(rest, fn(x) { x > pivot });
    append(append(simple_quicksort(smaller), [pivot]), simple_quicksort(larger))
}

// Find minimum and maximum
fn find_min([x]) { x }
fn find_min([x, ...xs]) {
    let min_rest = find_min(xs);
    if x <= min_rest { x } else { min_rest }
}

fn find_max([x]) { x }
fn find_max([x, ...xs]) {
    let max_rest = find_max(xs);
    if x >= max_rest { x } else { max_rest }
}

// Reverse a list
fn reverse_list(xs) { reverse_helper(xs, []) }

fn reverse_helper([], acc) { acc }
fn reverse_helper([x, ...xs], acc) {
    rec reverse_helper(xs, [x, ...acc])
}

log("=== Simple Algorithms Demo ===");

let test_data = [5, 2, 8, 1, 9, 3];
log("Original data:");
test_data |> log();

log("Insertion sort:");
test_data |> insert_sort() |> log();

log("Quicksort:");
test_data |> simple_quicksort() |> log();

log("Min and max:");
1 |> log(); // Expected min
9 |> log(); // Expected max

log("Reversed:");
test_data |> reverse_list() |> log();

// Test edge cases
log("Empty list sort:");
[] |> insert_sort() |> log();

log("Single element:");
[42] |> simple_quicksort() |> log();